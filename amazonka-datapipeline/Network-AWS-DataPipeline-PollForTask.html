<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Network.AWS.DataPipeline.PollForTask</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Network-AWS-DataPipeline-PollForTask.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">amazonka-datapipeline-0.2.2: Amazon Data Pipeline SDK.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Network.AWS.DataPipeline.PollForTask</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Request</a><ul><li><a href="#g:2">Request constructor</a></li><li><a href="#g:3">Request lenses</a></li></ul></li><li><a href="#g:4">Response</a><ul><li><a href="#g:5">Response constructor</a></li><li><a href="#g:6">Response lenses</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Task runners call this action to receive a task to perform from AWS Data
 Pipeline. The task runner specifies which tasks it can perform by setting a
 value for the workerGroup parameter of the <code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code> call. The task
 returned by <code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code> may come from any of the pipelines that match the
 workerGroup value passed in by the task runner and that was launched using
 the IAM user credentials specified by the task runner.</p><p>If tasks are ready in the work queue, <code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code> returns a response
 immediately. If no tasks are available in the queue, <code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code> uses
 long-polling and holds on to a poll connection for up to a 90 seconds during
 which time the first newly scheduled task is handed to the task runner. To
 accomodate this, set the socket timeout in your task runner to 90 seconds.
 The task runner should not call <code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code> again on the same <code>workerGroup</code>
 until it receives a response, and this may take up to 90 seconds.</p><p><a href="http://docs.aws.amazon.com/datapipeline/latest/APIReference/API_PollForTask.html">http://docs.aws.amazon.com/datapipeline/latest/APIReference/API_PollForTask.html</a></p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:PollForTask">PollForTask</a></li><li class="src short"><a href="#v:pollForTask">pollForTask</a> :: Text -&gt; <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></li><li class="src short"><a href="#v:pftHostname">pftHostname</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><a href="#v:pftInstanceIdentity">pftInstanceIdentity</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DataPipeline-Types.html#t:InstanceIdentity">InstanceIdentity</a>)</li><li class="src short"><a href="#v:pftWorkerGroup">pftWorkerGroup</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> Text</li><li class="src short"><span class="keyword">data</span> <a href="#t:PollForTaskResponse">PollForTaskResponse</a></li><li class="src short"><a href="#v:pollForTaskResponse">pollForTaskResponse</a> :: <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></li><li class="src short"><a href="#v:pftrTaskObject">pftrTaskObject</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DataPipeline-Types.html#t:TaskObject">TaskObject</a>)</li></ul></div><div id="interface"><h1 id="g:1">Request</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:PollForTask" class="def">PollForTask</a></p><div class="subs instances"><p id="control.i:PollForTask" class="caption collapser" onclick="toggleSection('i:PollForTask')">Instances</p><div id="section.i:PollForTask" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Text-Read.html#t:Read">Read</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSRequest <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToPath <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeaders <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sv <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> = <a href="Network-AWS-DataPipeline-Types.html#t:DataPipeline">DataPipeline</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rs <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> = <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:2">Request constructor</h2><div class="top"><p class="src"><a name="v:pollForTask" class="def">pollForTask</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Text</td><td class="doc"><p><code><a href="Network-AWS-DataPipeline-PollForTask.html#v:pftWorkerGroup">pftWorkerGroup</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code> constructor.</p><p>The fields accessible through corresponding lenses are:</p><ul><li><code><a href="Network-AWS-DataPipeline-PollForTask.html#v:pftHostname">pftHostname</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code>Text</code></li><li><code><a href="Network-AWS-DataPipeline-PollForTask.html#v:pftInstanceIdentity">pftInstanceIdentity</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="Network-AWS-DataPipeline-Types.html#t:InstanceIdentity">InstanceIdentity</a></code></li><li><code><a href="Network-AWS-DataPipeline-PollForTask.html#v:pftWorkerGroup">pftWorkerGroup</a></code> <code>::</code> <code>Text</code></li></ul></div></div><h2 id="g:3">Request lenses</h2><div class="top"><p class="src"><a name="v:pftHostname" class="def">pftHostname</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p><div class="doc"><p>The public DNS name of the calling task runner.</p></div></div><div class="top"><p class="src"><a name="v:pftInstanceIdentity" class="def">pftInstanceIdentity</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DataPipeline-Types.html#t:InstanceIdentity">InstanceIdentity</a>)</p><div class="doc"><p>Identity information for the Amazon EC2 instance that is hosting the task
 runner. You can get this value by calling the URI, 'http://169.254.169.254/latest/meta-data/instance-id', from the EC2 instance. For more information, go to <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AESDG-chapter-instancedata.html">Instance Metadata</a> in the <em>Amazon Elastic Compute Cloud User Guide.</em> Passing in this value proves that
 your task runner is running on an EC2 instance, and ensures the proper AWS
 Data Pipeline service charges are applied to your pipeline.</p></div></div><div class="top"><p class="src"><a name="v:pftWorkerGroup" class="def">pftWorkerGroup</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> Text</p><div class="doc"><p>Indicates the type of task the task runner is configured to accept and
 process. The worker group is set as a field on objects in the pipeline when
 they are created. You can only specify a single value for <code>workerGroup</code> in the
 call to <code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code>. There are no wildcard values permitted in <code>workerGroup</code>,
 the string must be an exact, case-sensitive, match.</p></div></div><h1 id="g:4">Response</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:PollForTaskResponse" class="def">PollForTaskResponse</a></p><div class="subs instances"><p id="control.i:PollForTaskResponse" class="caption collapser" onclick="toggleSection('i:PollForTaskResponse')">Instances</p><div id="section.i:PollForTaskResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Text-Read.html#t:Read">Read</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:5">Response constructor</h2><div class="top"><p class="src"><a name="v:pollForTaskResponse" class="def">pollForTaskResponse</a> :: <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></p><div class="doc"><p><code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></code> constructor.</p><p>The fields accessible through corresponding lenses are:</p><ul><li><code><a href="Network-AWS-DataPipeline-PollForTask.html#v:pftrTaskObject">pftrTaskObject</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="Network-AWS-DataPipeline-Types.html#t:TaskObject">TaskObject</a></code></li></ul></div></div><h2 id="g:6">Response lenses</h2><div class="top"><p class="src"><a name="v:pftrTaskObject" class="def">pftrTaskObject</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DataPipeline-Types.html#t:TaskObject">TaskObject</a>)</p><div class="doc"><p>An instance of <code><a href="Network-AWS-DataPipeline-Types.html#t:TaskObject">TaskObject</a></code>. The returned object contains all the information
 needed to complete the task that is being assigned to the task runner. One of
 the fields returned in this object is taskId, which contains an identifier
 for the task being assigned. The calling task runner uses taskId in
 subsequent calls to <code>ReportTaskProgress</code> and <code>SetTaskStatus</code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>